将main.c注释掉之后使用tests.c得到了如下的结果：
(1024 bytes, @0)
(1023 bytes, @1)
(1021 bytes, @3)
(1017 bytes, @7)
(1009 bytes, @15)
(993 bytes, @31)
(961 bytes, @63)
(897 bytes, @127)
(769 bytes, @255)
(513 bytes, @511)
(1 bytes, @1023)
(1 bytes, @0) (1 bytes, @1023)
(3 bytes, @0) (1 bytes, @1023)
(7 bytes, @0) (1 bytes, @1023)
(15 bytes, @0) (1 bytes, @1023)
(31 bytes, @0) (1 bytes, @1023)
(63 bytes, @0) (1 bytes, @1023)
(127 bytes, @0) (1 bytes, @1023)
(255 bytes, @0) (1 bytes, @1023)
(511 bytes, @0) (1 bytes, @1023)
第一个数字代表当前块还有多少空闲，第二个数字代表这个块实际内存中的偏移地址（模拟的）
我们运行的步骤是：从1到1024每个二的次方数依次alloc，然后依次free。
观察结果是这样的，首先alloc时每次会在结尾找一块内存去使用，然后free的时候会从前面开始观察找内存块开始合并到第一个块上，而且会最后那一个字节一直处于未被使用状态
